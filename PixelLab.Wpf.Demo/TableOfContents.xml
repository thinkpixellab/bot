<?xml version="1.0" encoding="utf-8" ?>
<Samples>
  <Sample Page="IntroductionPage.xaml" Title="Introduction" Description="The sample application is also a demo of sorts. The samples are populated in an XML document in TableOfContents.xml using an XmlDataProvider. Binding is used to change the content of the frame on the right when the selection changes. The content of this description Expander is also populated using the same trick. An IValueConverter is used to hide the Expander when there is no description for a given sample. The ControlTemplate for the Expander has also been modified to use the RevealDecorator so one gets a nice expand/collapse animation."/>
  <Sample Page="AnimatingTilePanelPage.xaml" Title="Animating Tile Panel" Description="This is a demonstration of two concepts: custom Panel creation and use of the Composition.Render event to do custom animations."/>
  <Sample Page="BlockBarPage.xaml" Title="BlockBar Control" Description="Sometimes you just want a control that does its own rendering without worrying about a template. This is an example of a control that supports all of the standard data binding tricks and also draws itself. A baseclass is used to centralize common infrastructure."/>
  <Sample Page="ColorPicker\ColorPickerPage.xaml" Title="ColorPicker Control" Description="This is ColorPicker. This control was written for my PDC'05 talk and put in the SDK. I've fixed a bunch of stuff since I posted the control for the PDC. I now use a private DP to handle the many-to-one binding of Color. I also implemented automation and cleaned up the default style (we're smarter about resources in theme files now)."/>
  <Sample Page="DateControlsPage.xaml" Title="Date Controls" Description="Two of the most requested controls have been re-born. Consider both of these controls to be high-quality samples, delivered by our friends in the Advanced Technology Center in Beijing. The controls are in the Library assembly and both have a default template that will work across themes. Feel free to use this code as you like and let me know if you have any questions, concerns, or suggestions."/>
  <Sample Page="FlipTile3D\FlipTile3DPage.xaml" Title="FlipTile3D" Description="This is my first messing around with WPF 3D. Figured I'm make something cool. :-)"/>
  <Sample Page="FolderPicker\FolderPickerPage.xaml" Title="Folder Picker" Description="This is an example of building a data layer to enable data binding. In this case, around multi-selecting folders."/>
  <Sample Page="Graph\GraphPage.xaml" Title="Graph" Description="This is an example of supporting multi-item data binding without using ItemsControl. It uses tricks that are similar to AnimatingTilePanel, specifically physics inspired custom animations using CompsitionTarget.Render."/>
  <Sample Page="Hex\HexPage.xaml" Title="Hex" Description="Games are a great way to learn a UI framework. Hex is a great game. Find out about the rules here: http://en.wikipedia.org/wiki/Hex_(board_game)"/>
  <Sample Page="InfoTextBoxPage.xaml" Title="InfoTextBox" Description="When should I build a custom control? This is a question I get a lot. I think InfoTextBox is a great example of a where a custom control adds a lot of value. You'll notice that I didn't start from scratch. I simply added a couple of properties to the existing TextBox. The properties I add are pretty boring, actually, just HasText (bool) and TextBoxInfo (string). The magic comes when I leverage these new properties in a new ControlTemplate for InfoTextBox. I think you'll agree that the results are pretty cool."/>
  <Sample Page="Interactive3DPage.xaml" Title="Interactive 3D" Description="Shows what's possible with 2D-on-3D, input, and eventing. These are new 3D features in .NET 3.5. Thanks to Kurt Berglund for doing the heavy lifting on the 3D side."/>
  <Sample Page="KevinButton\KevinButtonPage.xaml" Title="KevinButton" Description="If you must know: http://channel9.msdn.com/showpost.aspx?postid=222817"/>
  <Sample Page="ListPagerPage.xaml" Title="List Pager" Description="This is another example of how a 'smart' data layer can minimize the number and complexity of custom elements you need to create."/>
  <Sample Page="MineSweeper\MineSweeperPage.xaml" Title="Mine Sweeper" Description="An oldy, but a goody. Done in WPF. Custom templates are used a lot here."/>
  <Sample Page="NotifyWorkerPage.xaml" Title="NotifyWorker"/>
  <Sample Page="NumericUpDownPage.xaml" Title="NumericUpDown Control" Description="NumericUpDown is a control I am frequently asked about, so I thought I'd write it. I was briefly tempted to subclass RangeBase for this, but at the end of the day, one really wants Decimal to be the base value, and RangeBase uses Double. There's quite a bit going on here: lot's of nested, styled controls. Binding. Commands. RoutedEvents. DependencyProperty Coercion. Like InfoTextBox, this control and its resources lives in an external library. Feel free to reuse it. This is still a work in progress, but I think most of the work is in the style (maybe a little to handle up-down arrow keys)."/>
  <Sample Page="OrgTree\OrgTreePage.xaml" Title="Org Tree" Description="A play off treeview, but stacked like an org chart. Right-click on nodes to add or remove children."/>
  <Sample Page="RadioButtonListPage.xaml" Title="RadioButtonList" Description="I've received a lot of questions about RadioButtonList (RBL). Why don't we have it as a control? The decision was a long and interesting one. At the end of the day we decided it was just too easy to build an RBL by styling a ListBox. (We had a whole host of other issues, too, but I won't bore you with them.) The power of using styling is that you can take an ordinary, data-bound ListBox and make it look like an RBL. Pretty cool."/>
  <Sample Page="ReorderListBoxPage.xaml" Title="ReorderListBox"/>
  <Sample Page="RevealPage.xaml" Title="Reveal" Description="This is a great example of how a custom widget--namely, Reveal--can be used in a number of places. TreeView and Expander, for example."/>
  <Sample Page="Set\SetPage.xaml" Title="Set Game" Description="The game Set in WPF."/>
  <Sample Page="ShowElementPage.xaml" Title="ShowElement" Description="A simple element used to 'show' a series of UIElements."/>
  <Sample Page="TransitionPresenter\TransitionPresenterPage.xaml" Title="TransitionPresenter" Description="Before Neil went off to hack on the Zune app, he made one of the most impressive WPF demos. Kudos!"/>
  <Sample Page="TreeMapPanelPage.xaml" Title="TreeMapPanel" Description="Another example of a custom panel."/>
  <Sample Page="TreeViewDoubleClickPage.xaml" Title="TreeView Double-Click" Description="This is really two demos: 1) It's a demo of adding double-click handling to an items control. Since Click is a RoutedEvent, you can listen to it anywhere up the tree. Here I just use it to find the TreeViewItem that was double-clicked and show the XML content that is bound to it. You can use the same logic in a ListBox, if you like. 2) It's a demo of XML binding to a TreeView. (Since the folder picker already does CLR binding.) Take a look at the XAML. You'll see we have full XPath support."/>
  <Sample Page="TreeViewHelperClasses\TreeViewHelperPage.xaml" Title="TreeView Expand" Description="This 'trick' is a demo of a couple classes I’ve added to the Library assembly. Expand by objects” uses the TreeViewHelper.Show method that takes an array of objects and shows the element that is represented by the corresponding path. 'Expand by indices' does something similar, using a different overload of TreeViewHelper.Show that uses an array of ints that represent the index at each level of the data model that corresponds to the desired TreeViewItem. Both 'Expand by objects' and 'Expand by indicies' work off a randomly generated path. If nothing happens when you click, either refresh the data or click again. 'Expand All' calls TreeViewHelper.ExpandAll, which does similar tricks to the previous two, but does it for every node under a given TreeView/TreeViewItem. 'Expand All (via data)' uses the preferred way to expand nodes in a TreeView. A similar method could be used to expand just a single node. Expand is pushed to the data layer and bound to the UI. Notice how much faster it is. This is an option if you can modify your data layer...although you’ll notice that I actually use a wrapper class (TreeViewDataItem) which could be used with almost any data model to support Show/ExpandAll."/>
  <Sample Page="VisualTreeViewer\VisualTreeViewerPage.xaml" Title="Visual Tree Viewer" Description="This may seem a bit silly, but it's such a great demo and amazingly useful every once-in-a-while. So I have a ListBox with a bunch of random stuff in it. What does the visual tree look like? What are the actual WPF elements that are getting created? Well, WPF has VisualTreeWalker which will let you get the children of any Visual. You could write some debug spew to walk the tree out to the Console. Or, you could create a helper class VisualTreeItem, point it at the root element you care about when you click a button, and bind to it with a TreeView. Yeah, a bit silly. :-)"/>
  <Sample Page="XamlShirt.xaml" Title="XAML T-Shirt" Description="A super-simple and super-silly example of control templates gone too far."/>
  <Sample Page="VSCopyToHtmlPage.xaml" Title="VS to HTML"/>
  <Sample Page="ZapPage.xaml" Title="Zap Scroller" Description="An example of the union between custom elements, custom animation, and data binding."/>
</Samples>
